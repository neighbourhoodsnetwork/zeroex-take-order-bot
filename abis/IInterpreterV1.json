{
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IInterpreterStoreV1",
          "name": "store",
          "type": "address"
        },
        {
          "internalType": "StateNamespace",
          "name": "namespace",
          "type": "uint256"
        },
        {
          "internalType": "EncodedDispatch",
          "name": "dispatch",
          "type": "uint256"
        },
        {
          "internalType": "uint256[][]",
          "name": "context",
          "type": "uint256[][]"
        }
      ],
      "name": "eval",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "stack",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "kvs",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "functionPointers",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "bytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "deployedBytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "methodIdentifiers": {
    "eval(address,uint256,uint256,uint256[][])": "6715f825",
    "functionPointers()": "f933c72f"
  },
  "rawMetadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"StateNamespace\",\"name\":\"namespace\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"context\",\"type\":\"uint256[][]\"}],\"name\":\"eval\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stack\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"kvs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"functionPointers\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"eval(address,uint256,uint256,uint256[][])\":{\"params\":{\"context\":\"A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting. Same as `eval` but allowing the caller to specify a namespace under which the state changes will be applied. The interpeter MUST ensure that keys will never collide across namespaces, even if, for example: - The calling contract is malicious and attempts to craft a collision   with state changes from another contract - The expression is malicious and attempts to craft a collision with   other expressions evaluated by the same calling contract A malicious entity MAY have access to significant offchain resources to attempt to precompute key collisions through brute force. The collision resistance of namespaces should be comparable or equivalent to the collision resistance of the hashing algorithms employed by the blockchain itself, such as the design of `mapping` in Solidity that hashes each nested key to produce a collision resistant compound key.\",\"dispatch\":\"All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to `LibEncodedDispatch` but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.\",\"namespace\":\"The state namespace that will be fully qualified by the interpreter at runtime in order to perform gets on the underlying store. MUST be the same namespace passed to the store by the calling contract when sending the resulting key/value items to storage.\",\"store\":\"The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass `address(0)`.\"},\"returns\":{\"kvs\":\"A list of pairwise key/value items to be saved in the store.\",\"stack\":\"The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by `dispatch`, if applicable.\"}}},\"title\":\"IInterpreterV1 Interface into a standard interpreter that supports: - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1` - receiving arbitrary `uint256[][]` supporting context to be made available   to the evaluated logic - handling subsequent state changes in bulk in response to evaluated logic - namespacing state changes according to the caller's preferences to avoid   unwanted key collisions - exposing its internal function pointers to support external precompilation   of logic for more gas efficient runtime evaluation by the interpreter The interface is designed to be stable across many versions and implementations of an interpreter, balancing minimalism with features required for a general purpose onchain interpreted compute environment. The security model of an interpreter is that it MUST be resilient to malicious expressions even if they dispatch arbitrary internal function pointers during an eval. The interpreter MAY return garbage or exhibit undefined behaviour or error during an eval, _provided that no state changes are persisted_ e.g. in storage, such that only the caller that specifies the malicious expression can be negatively impacted by the result. In turn, the caller must guard itself against arbitrarily corrupt/malicious reverts and return values from any interpreter that it requests an expression from. And so on and so forth up to the externally owned account (EOA) who signs the transaction and agrees to a specific combination of contracts, expressions and interpreters, who can presumably make an informed decision about which ones to trust to get the job done. The state changes for an interpreter are expected to be produces by an `eval` and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the caller, after the caller has had an opportunity to apply their own intermediate logic such as reentrancy defenses against malicious interpreters. The interpreter is free to structure the state changes however it wants but MUST guard against the calling contract corrupting the changes between `eval` and `set`. For example a store could sandbox storage writes per-caller so that a malicious caller can only damage their own state changes, while honest callers respect, benefit from and are protected by the interpreter store's state change handling. The two step eval-state model allows eval to be read-only which provides security guarantees for the caller such as no stateful reentrancy, either from the interpreter or some contract interface used by some word, while still allowing for storage writes. As the storage writes happen on the interpreter rather than the caller (c.f. delegate call) the caller DOES NOT need to trust the interpreter, which allows for permissionless selection of interpreters by end users. Delegate call always implies an admin key on the caller because the delegatee contract can write arbitrarily to the state of the delegator, which severely limits the generality of contract composition.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"eval(address,uint256,uint256,uint256[][])\":{\"notice\":\"The raison d'etre for an interpreter. Given some expression and per-call additional contextual data, produce a stack of results and a set of state changes that the caller MAY OPTIONALLY pass back to be persisted by a call to `IInterpreterStoreV1.set`.\"},\"functionPointers()\":{\"notice\":\"Exposes the function pointers as `uint16` values packed into a single `bytes` in the same order as they would be indexed into by opcodes. For example, if opcode `2` should dispatch function at position `0x1234` then the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is a placeholder for the function pointers of opcodes `0` and `1`. `IExpressionDeployerV1` contracts use these function pointers to \\\"compile\\\" the expression into something that an interpreter can dispatch directly without paying gas to lookup the same at runtime. As the validity of any integrity check and subsequent dispatch is highly sensitive to both the function pointers and overall bytecode of the interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards against accidentally being deployed onchain paired against an unknown interpreter. It is very easy for an apparent compatible pairing to be subtly and critically incompatible due to addition/removal/reordering of opcodes and compiler optimisations on the interpreter bytecode. This MAY return different values during construction vs. all other times after the interpreter has been successfully deployed onchain. DO NOT rely on function pointers reported during contract construction.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interface.interpreter/src/IInterpreterV1.sol\":\"IInterpreterV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@openzeppelin/=node_modules/@openzeppelin/\",\":@prb/=node_modules/@prb/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":eth-gas-reporter/=node_modules/eth-gas-reporter/\",\":forge-std/=lib/forge-std/src/\",\":hardhat/=node_modules/hardhat/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.interface.factory/=lib/rain.interface.factory/src/\",\":rain.interface.flow/=lib/rain.interface.flow/src/\",\":rain.interface.interpreter/=lib/rain.interface.interpreter/src/\",\":rain.interface.orderbook/=lib/rain.interface.orderbook/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.lib.hash/=lib/rain.interface.interpreter/lib/rain.lib.hash/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\",\":sol.metadata/=lib/sol.metadata/src/\"]},\"sources\":{\"lib/rain.interface.interpreter/src/IInterpreterStoreV1.sol\":{\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\",\"urls\":[\"bzz-raw://30bb6f09d8b8f27f77e6c44591c4f2070286a91dad202043cf2351ae802e3df5\",\"dweb:/ipfs/QmRz5pfzf5w84iNmKaYYbqP8oQywzc5xbd3xzKmxgFyf9y\"]},\"lib/rain.interface.interpreter/src/IInterpreterV1.sol\":{\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\",\"urls\":[\"bzz-raw://b93fb28a09aeea4afe7f0d4afc67354c0fa538e5a9b274b0c5f10ed1dd6b6b00\",\"dweb:/ipfs/QmatNhoHRSJ1ZvoCNo61YMt9jb1vvEkWy3mkcoPkB4FFA9\"]}},\"version\":1}",
  "metadata": {
    "compiler": {
      "version": "0.8.19+commit.7dd6d404"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "contract IInterpreterStoreV1",
              "name": "store",
              "type": "address"
            },
            {
              "internalType": "StateNamespace",
              "name": "namespace",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "uint256[][]",
              "name": "context",
              "type": "uint256[][]"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "eval",
          "outputs": [
            {
              "internalType": "uint256[]",
              "name": "stack",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "kvs",
              "type": "uint256[]"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "functionPointers",
          "outputs": [
            {
              "internalType": "bytes",
              "name": "",
              "type": "bytes"
            }
          ]
        }
      ],
      "devdoc": {
        "kind": "dev",
        "methods": {
          "eval(address,uint256,uint256,uint256[][])": {
            "params": {
              "context": "A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting. Same as `eval` but allowing the caller to specify a namespace under which the state changes will be applied. The interpeter MUST ensure that keys will never collide across namespaces, even if, for example: - The calling contract is malicious and attempts to craft a collision   with state changes from another contract - The expression is malicious and attempts to craft a collision with   other expressions evaluated by the same calling contract A malicious entity MAY have access to significant offchain resources to attempt to precompute key collisions through brute force. The collision resistance of namespaces should be comparable or equivalent to the collision resistance of the hashing algorithms employed by the blockchain itself, such as the design of `mapping` in Solidity that hashes each nested key to produce a collision resistant compound key.",
              "dispatch": "All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to `LibEncodedDispatch` but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.",
              "namespace": "The state namespace that will be fully qualified by the interpreter at runtime in order to perform gets on the underlying store. MUST be the same namespace passed to the store by the calling contract when sending the resulting key/value items to storage.",
              "store": "The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass `address(0)`."
            },
            "returns": {
              "kvs": "A list of pairwise key/value items to be saved in the store.",
              "stack": "The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by `dispatch`, if applicable."
            }
          }
        },
        "version": 1
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "eval(address,uint256,uint256,uint256[][])": {
            "notice": "The raison d'etre for an interpreter. Given some expression and per-call additional contextual data, produce a stack of results and a set of state changes that the caller MAY OPTIONALLY pass back to be persisted by a call to `IInterpreterStoreV1.set`."
          },
          "functionPointers()": {
            "notice": "Exposes the function pointers as `uint16` values packed into a single `bytes` in the same order as they would be indexed into by opcodes. For example, if opcode `2` should dispatch function at position `0x1234` then the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is a placeholder for the function pointers of opcodes `0` and `1`. `IExpressionDeployerV1` contracts use these function pointers to \"compile\" the expression into something that an interpreter can dispatch directly without paying gas to lookup the same at runtime. As the validity of any integrity check and subsequent dispatch is highly sensitive to both the function pointers and overall bytecode of the interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards against accidentally being deployed onchain paired against an unknown interpreter. It is very easy for an apparent compatible pairing to be subtly and critically incompatible due to addition/removal/reordering of opcodes and compiler optimisations on the interpreter bytecode. This MAY return different values during construction vs. all other times after the interpreter has been successfully deployed onchain. DO NOT rely on function pointers reported during contract construction."
          }
        },
        "version": 1
      }
    },
    "settings": {
      "remappings": [
        ":@openzeppelin/=node_modules/@openzeppelin/",
        ":@prb/=node_modules/@prb/",
        ":ds-test/=lib/forge-std/lib/ds-test/src/",
        ":eth-gas-reporter/=node_modules/eth-gas-reporter/",
        ":forge-std/=lib/forge-std/src/",
        ":hardhat/=node_modules/hardhat/",
        ":openzeppelin-contracts/=lib/openzeppelin-contracts/",
        ":rain.cooldown/=lib/rain.cooldown/src/",
        ":rain.interface.factory/=lib/rain.interface.factory/src/",
        ":rain.interface.flow/=lib/rain.interface.flow/src/",
        ":rain.interface.interpreter/=lib/rain.interface.interpreter/src/",
        ":rain.interface.orderbook/=lib/rain.interface.orderbook/src/",
        ":rain.interface.sale/=lib/rain.interface.sale/src/",
        ":rain.lib.hash/=lib/rain.interface.interpreter/lib/rain.lib.hash/src/",
        ":rain.lib.typecast/=lib/rain.lib.typecast/src/",
        ":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/",
        ":rain.math.saturating/=lib/rain.math.saturating/src/",
        ":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/",
        ":sol.lib.datacontract/=lib/sol.lib.datacontract/src/",
        ":sol.lib.memory/=lib/sol.lib.memory/src/",
        ":sol.metadata/=lib/sol.metadata/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "metadata": {
        "bytecodeHash": "ipfs"
      },
      "compilationTarget": {
        "lib/rain.interface.interpreter/src/IInterpreterV1.sol": "IInterpreterV1"
      },
      "libraries": {}
    },
    "sources": {
      "lib/rain.interface.interpreter/src/IInterpreterStoreV1.sol": {
        "keccak256": "0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619",
        "urls": [
          "bzz-raw://30bb6f09d8b8f27f77e6c44591c4f2070286a91dad202043cf2351ae802e3df5",
          "dweb:/ipfs/QmRz5pfzf5w84iNmKaYYbqP8oQywzc5xbd3xzKmxgFyf9y"
        ],
        "license": "CAL"
      },
      "lib/rain.interface.interpreter/src/IInterpreterV1.sol": {
        "keccak256": "0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293",
        "urls": [
          "bzz-raw://b93fb28a09aeea4afe7f0d4afc67354c0fa538e5a9b274b0c5f10ed1dd6b6b00",
          "dweb:/ipfs/QmatNhoHRSJ1ZvoCNo61YMt9jb1vvEkWy3mkcoPkB4FFA9"
        ],
        "license": "CAL"
      }
    },
    "version": 1
  },
  "ast": {
    "absolutePath": "lib/rain.interface.interpreter/src/IInterpreterV1.sol",
    "id": 37098,
    "exportedSymbols": {
      "DEFAULT_STATE_NAMESPACE": [
        37066
      ],
      "EncodedDispatch": [
        37054
      ],
      "FullyQualifiedNamespace": [
        37015
      ],
      "IInterpreterStoreV1": [
        37047
      ],
      "IInterpreterV1": [
        37097
      ],
      "NO_STORE": [
        37024
      ],
      "Operand": [
        37058
      ],
      "SourceIndex": [
        37052
      ],
      "StateNamespace": [
        37056
      ]
    },
    "nodeType": "SourceUnit",
    "src": "32:9059:196",
    "nodes": [
      {
        "id": 37049,
        "nodeType": "PragmaDirective",
        "src": "32:24:196",
        "nodes": [],
        "literals": [
          "solidity",
          "^",
          "0.8",
          ".18"
        ]
      },
      {
        "id": 37050,
        "nodeType": "ImportDirective",
        "src": "58:35:196",
        "nodes": [],
        "absolutePath": "lib/rain.interface.interpreter/src/IInterpreterStoreV1.sol",
        "file": "./IInterpreterStoreV1.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 37098,
        "sourceUnit": 37048,
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "id": 37052,
        "nodeType": "UserDefinedValueTypeDefinition",
        "src": "303:27:196",
        "nodes": [],
        "canonicalName": "SourceIndex",
        "name": "SourceIndex",
        "nameLocation": "308:11:196",
        "underlyingType": {
          "id": 37051,
          "name": "uint16",
          "nodeType": "ElementaryTypeName",
          "src": "323:6:196",
          "typeDescriptions": {
            "typeIdentifier": "t_uint16",
            "typeString": "uint16"
          }
        }
      },
      {
        "id": 37054,
        "nodeType": "UserDefinedValueTypeDefinition",
        "src": "474:32:196",
        "nodes": [],
        "canonicalName": "EncodedDispatch",
        "name": "EncodedDispatch",
        "nameLocation": "479:15:196",
        "underlyingType": {
          "id": 37053,
          "name": "uint256",
          "nodeType": "ElementaryTypeName",
          "src": "498:7:196",
          "typeDescriptions": {
            "typeIdentifier": "t_uint256",
            "typeString": "uint256"
          }
        }
      },
      {
        "id": 37056,
        "nodeType": "UserDefinedValueTypeDefinition",
        "src": "679:31:196",
        "nodes": [],
        "canonicalName": "StateNamespace",
        "name": "StateNamespace",
        "nameLocation": "684:14:196",
        "underlyingType": {
          "id": 37055,
          "name": "uint256",
          "nodeType": "ElementaryTypeName",
          "src": "702:7:196",
          "typeDescriptions": {
            "typeIdentifier": "t_uint256",
            "typeString": "uint256"
          }
        }
      },
      {
        "id": 37058,
        "nodeType": "UserDefinedValueTypeDefinition",
        "src": "907:24:196",
        "nodes": [],
        "canonicalName": "Operand",
        "name": "Operand",
        "nameLocation": "912:7:196",
        "underlyingType": {
          "id": 37057,
          "name": "uint256",
          "nodeType": "ElementaryTypeName",
          "src": "923:7:196",
          "typeDescriptions": {
            "typeIdentifier": "t_uint256",
            "typeString": "uint256"
          }
        }
      },
      {
        "id": 37066,
        "nodeType": "VariableDeclaration",
        "src": "1072:72:196",
        "nodes": [],
        "constant": true,
        "mutability": "constant",
        "name": "DEFAULT_STATE_NAMESPACE",
        "nameLocation": "1096:23:196",
        "scope": 37098,
        "stateVariable": false,
        "storageLocation": "default",
        "typeDescriptions": {
          "typeIdentifier": "t_userDefinedValueType$_StateNamespace_$37056",
          "typeString": "StateNamespace"
        },
        "typeName": {
          "id": 37061,
          "nodeType": "UserDefinedTypeName",
          "pathNode": {
            "id": 37060,
            "name": "StateNamespace",
            "nameLocations": [
              "1072:14:196"
            ],
            "nodeType": "IdentifierPath",
            "referencedDeclaration": 37056,
            "src": "1072:14:196"
          },
          "referencedDeclaration": 37056,
          "src": "1072:14:196",
          "typeDescriptions": {
            "typeIdentifier": "t_userDefinedValueType$_StateNamespace_$37056",
            "typeString": "StateNamespace"
          }
        },
        "value": {
          "arguments": [
            {
              "hexValue": "30",
              "id": 37064,
              "isConstant": false,
              "isLValue": false,
              "isPure": true,
              "kind": "number",
              "lValueRequested": false,
              "nodeType": "Literal",
              "src": "1142:1:196",
              "typeDescriptions": {
                "typeIdentifier": "t_rational_0_by_1",
                "typeString": "int_const 0"
              },
              "value": "0"
            }
          ],
          "expression": {
            "argumentTypes": [
              {
                "typeIdentifier": "t_rational_0_by_1",
                "typeString": "int_const 0"
              }
            ],
            "expression": {
              "id": 37062,
              "name": "StateNamespace",
              "nodeType": "Identifier",
              "overloadedDeclarations": [],
              "referencedDeclaration": 37056,
              "src": "1122:14:196",
              "typeDescriptions": {
                "typeIdentifier": "t_type$_t_userDefinedValueType$_StateNamespace_$37056_$",
                "typeString": "type(StateNamespace)"
              }
            },
            "id": 37063,
            "isConstant": false,
            "isLValue": false,
            "isPure": true,
            "lValueRequested": false,
            "memberLocation": "1137:4:196",
            "memberName": "wrap",
            "nodeType": "MemberAccess",
            "src": "1122:19:196",
            "typeDescriptions": {
              "typeIdentifier": "t_function_wrap_pure$_t_uint256_$returns$_t_userDefinedValueType$_StateNamespace_$37056_$",
              "typeString": "function (uint256) pure returns (StateNamespace)"
            }
          },
          "id": 37065,
          "isConstant": false,
          "isLValue": false,
          "isPure": true,
          "kind": "functionCall",
          "lValueRequested": false,
          "nameLocations": [],
          "names": [],
          "nodeType": "FunctionCall",
          "src": "1122:22:196",
          "tryCall": false,
          "typeDescriptions": {
            "typeIdentifier": "t_userDefinedValueType$_StateNamespace_$37056",
            "typeString": "StateNamespace"
          }
        },
        "visibility": "internal"
      },
      {
        "id": 37097,
        "nodeType": "ContractDefinition",
        "src": "4350:4740:196",
        "nodes": [
          {
            "id": 37073,
            "nodeType": "FunctionDefinition",
            "src": "5785:65:196",
            "nodes": [],
            "documentation": {
              "id": 37068,
              "nodeType": "StructuredDocumentation",
              "src": "4381:1399:196",
              "text": "Exposes the function pointers as `uint16` values packed into a single\n `bytes` in the same order as they would be indexed into by opcodes. For\n example, if opcode `2` should dispatch function at position `0x1234` then\n the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\n a placeholder for the function pointers of opcodes `0` and `1`.\n `IExpressionDeployerV1` contracts use these function pointers to\n \"compile\" the expression into something that an interpreter can dispatch\n directly without paying gas to lookup the same at runtime. As the\n validity of any integrity check and subsequent dispatch is highly\n sensitive to both the function pointers and overall bytecode of the\n interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\n against accidentally being deployed onchain paired against an unknown\n interpreter. It is very easy for an apparent compatible pairing to be\n subtly and critically incompatible due to addition/removal/reordering of\n opcodes and compiler optimisations on the interpreter bytecode.\n This MAY return different values during construction vs. all other times\n after the interpreter has been successfully deployed onchain. DO NOT rely\n on function pointers reported during contract construction."
            },
            "functionSelector": "f933c72f",
            "implemented": false,
            "kind": "function",
            "modifiers": [],
            "name": "functionPointers",
            "nameLocation": "5794:16:196",
            "parameters": {
              "id": 37069,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "5810:2:196"
            },
            "returnParameters": {
              "id": 37072,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 37071,
                  "mutability": "mutable",
                  "name": "",
                  "nameLocation": "-1:-1:-1",
                  "nodeType": "VariableDeclaration",
                  "scope": 37073,
                  "src": "5836:12:196",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 37070,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "5836:5:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "5835:14:196"
            },
            "scope": 37097,
            "stateMutability": "view",
            "virtual": false,
            "visibility": "external"
          },
          {
            "id": 37096,
            "nodeType": "FunctionDefinition",
            "src": "8858:230:196",
            "nodes": [],
            "documentation": {
              "id": 37074,
              "nodeType": "StructuredDocumentation",
              "src": "5856:2997:196",
              "text": "The raison d'etre for an interpreter. Given some expression and per-call\n additional contextual data, produce a stack of results and a set of state\n changes that the caller MAY OPTIONALLY pass back to be persisted by a\n call to `IInterpreterStoreV1.set`.\n @param store The storage contract that the returned key/value pairs\n MUST be passed to IF the calling contract is in a non-static calling\n context. Static calling contexts MUST pass `address(0)`.\n @param namespace The state namespace that will be fully qualified by the\n interpreter at runtime in order to perform gets on the underlying store.\n MUST be the same namespace passed to the store by the calling contract\n when sending the resulting key/value items to storage.\n @param dispatch All the information required for the interpreter to load\n an expression, select an entrypoint and return the values expected by the\n caller. The interpreter MAY encode dispatches differently to\n `LibEncodedDispatch` but this WILL negatively impact compatibility for\n calling contracts that hardcode the encoding logic.\n @param context A 2-dimensional array of data that can be indexed into at\n runtime by the interpreter. The calling contract is responsible for\n ensuring the authenticity and completeness of context data. The\n interpreter MUST revert at runtime if an expression attempts to index\n into some context value that is not provided by the caller. This implies\n that context reads cannot be checked for out of bounds reads at deploy\n time, as the runtime context MAY be provided in a different shape to what\n the expression is expecting.\n Same as `eval` but allowing the caller to specify a namespace under which\n the state changes will be applied. The interpeter MUST ensure that keys\n will never collide across namespaces, even if, for example:\n - The calling contract is malicious and attempts to craft a collision\n   with state changes from another contract\n - The expression is malicious and attempts to craft a collision with\n   other expressions evaluated by the same calling contract\n A malicious entity MAY have access to significant offchain resources to\n attempt to precompute key collisions through brute force. The collision\n resistance of namespaces should be comparable or equivalent to the\n collision resistance of the hashing algorithms employed by the blockchain\n itself, such as the design of `mapping` in Solidity that hashes each\n nested key to produce a collision resistant compound key.\n @return stack The list of values produced by evaluating the expression.\n MUST NOT be longer than the maximum length specified by `dispatch`, if\n applicable.\n @return kvs A list of pairwise key/value items to be saved in the store."
            },
            "functionSelector": "6715f825",
            "implemented": false,
            "kind": "function",
            "modifiers": [],
            "name": "eval",
            "nameLocation": "8867:4:196",
            "parameters": {
              "id": 37088,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 37077,
                  "mutability": "mutable",
                  "name": "store",
                  "nameLocation": "8901:5:196",
                  "nodeType": "VariableDeclaration",
                  "scope": 37096,
                  "src": "8881:25:196",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_contract$_IInterpreterStoreV1_$37047",
                    "typeString": "contract IInterpreterStoreV1"
                  },
                  "typeName": {
                    "id": 37076,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 37075,
                      "name": "IInterpreterStoreV1",
                      "nameLocations": [
                        "8881:19:196"
                      ],
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 37047,
                      "src": "8881:19:196"
                    },
                    "referencedDeclaration": 37047,
                    "src": "8881:19:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_contract$_IInterpreterStoreV1_$37047",
                      "typeString": "contract IInterpreterStoreV1"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 37080,
                  "mutability": "mutable",
                  "name": "namespace",
                  "nameLocation": "8931:9:196",
                  "nodeType": "VariableDeclaration",
                  "scope": 37096,
                  "src": "8916:24:196",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_userDefinedValueType$_StateNamespace_$37056",
                    "typeString": "StateNamespace"
                  },
                  "typeName": {
                    "id": 37079,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 37078,
                      "name": "StateNamespace",
                      "nameLocations": [
                        "8916:14:196"
                      ],
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 37056,
                      "src": "8916:14:196"
                    },
                    "referencedDeclaration": 37056,
                    "src": "8916:14:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_userDefinedValueType$_StateNamespace_$37056",
                      "typeString": "StateNamespace"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 37083,
                  "mutability": "mutable",
                  "name": "dispatch",
                  "nameLocation": "8966:8:196",
                  "nodeType": "VariableDeclaration",
                  "scope": 37096,
                  "src": "8950:24:196",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_userDefinedValueType$_EncodedDispatch_$37054",
                    "typeString": "EncodedDispatch"
                  },
                  "typeName": {
                    "id": 37082,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 37081,
                      "name": "EncodedDispatch",
                      "nameLocations": [
                        "8950:15:196"
                      ],
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 37054,
                      "src": "8950:15:196"
                    },
                    "referencedDeclaration": 37054,
                    "src": "8950:15:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_userDefinedValueType$_EncodedDispatch_$37054",
                      "typeString": "EncodedDispatch"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 37087,
                  "mutability": "mutable",
                  "name": "context",
                  "nameLocation": "9005:7:196",
                  "nodeType": "VariableDeclaration",
                  "scope": 37096,
                  "src": "8984:28:196",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_array$_t_uint256_$dyn_calldata_ptr_$dyn_calldata_ptr",
                    "typeString": "uint256[][]"
                  },
                  "typeName": {
                    "baseType": {
                      "baseType": {
                        "id": 37084,
                        "name": "uint256",
                        "nodeType": "ElementaryTypeName",
                        "src": "8984:7:196",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "id": 37085,
                      "nodeType": "ArrayTypeName",
                      "src": "8984:9:196",
                      "typeDescriptions": {
                        "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                        "typeString": "uint256[]"
                      }
                    },
                    "id": 37086,
                    "nodeType": "ArrayTypeName",
                    "src": "8984:11:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_array$_t_uint256_$dyn_storage_$dyn_storage_ptr",
                      "typeString": "uint256[][]"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "8871:147:196"
            },
            "returnParameters": {
              "id": 37095,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 37091,
                  "mutability": "mutable",
                  "name": "stack",
                  "nameLocation": "9059:5:196",
                  "nodeType": "VariableDeclaration",
                  "scope": 37096,
                  "src": "9042:22:196",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$dyn_memory_ptr",
                    "typeString": "uint256[]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 37089,
                      "name": "uint256",
                      "nodeType": "ElementaryTypeName",
                      "src": "9042:7:196",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 37090,
                    "nodeType": "ArrayTypeName",
                    "src": "9042:9:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                      "typeString": "uint256[]"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 37094,
                  "mutability": "mutable",
                  "name": "kvs",
                  "nameLocation": "9083:3:196",
                  "nodeType": "VariableDeclaration",
                  "scope": 37096,
                  "src": "9066:20:196",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$dyn_memory_ptr",
                    "typeString": "uint256[]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 37092,
                      "name": "uint256",
                      "nodeType": "ElementaryTypeName",
                      "src": "9066:7:196",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 37093,
                    "nodeType": "ArrayTypeName",
                    "src": "9066:9:196",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                      "typeString": "uint256[]"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "9041:46:196"
            },
            "scope": 37097,
            "stateMutability": "view",
            "virtual": false,
            "visibility": "external"
          }
        ],
        "abstract": false,
        "baseContracts": [],
        "canonicalName": "IInterpreterV1",
        "contractDependencies": [],
        "contractKind": "interface",
        "documentation": {
          "id": 37067,
          "nodeType": "StructuredDocumentation",
          "src": "1147:3203:196",
          "text": "@title IInterpreterV1\n Interface into a standard interpreter that supports:\n - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\n - receiving arbitrary `uint256[][]` supporting context to be made available\n   to the evaluated logic\n - handling subsequent state changes in bulk in response to evaluated logic\n - namespacing state changes according to the caller's preferences to avoid\n   unwanted key collisions\n - exposing its internal function pointers to support external precompilation\n   of logic for more gas efficient runtime evaluation by the interpreter\n The interface is designed to be stable across many versions and\n implementations of an interpreter, balancing minimalism with features\n required for a general purpose onchain interpreted compute environment.\n The security model of an interpreter is that it MUST be resilient to\n malicious expressions even if they dispatch arbitrary internal function\n pointers during an eval. The interpreter MAY return garbage or exhibit\n undefined behaviour or error during an eval, _provided that no state changes\n are persisted_ e.g. in storage, such that only the caller that specifies the\n malicious expression can be negatively impacted by the result. In turn, the\n caller must guard itself against arbitrarily corrupt/malicious reverts and\n return values from any interpreter that it requests an expression from. And\n so on and so forth up to the externally owned account (EOA) who signs the\n transaction and agrees to a specific combination of contracts, expressions\n and interpreters, who can presumably make an informed decision about which\n ones to trust to get the job done.\n The state changes for an interpreter are expected to be produces by an `eval`\n and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\n caller, after the caller has had an opportunity to apply their own\n intermediate logic such as reentrancy defenses against malicious\n interpreters. The interpreter is free to structure the state changes however\n it wants but MUST guard against the calling contract corrupting the changes\n between `eval` and `set`. For example a store could sandbox storage writes\n per-caller so that a malicious caller can only damage their own state\n changes, while honest callers respect, benefit from and are protected by the\n interpreter store's state change handling.\n The two step eval-state model allows eval to be read-only which provides\n security guarantees for the caller such as no stateful reentrancy, either\n from the interpreter or some contract interface used by some word, while\n still allowing for storage writes. As the storage writes happen on the\n interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\n need to trust the interpreter, which allows for permissionless selection of\n interpreters by end users. Delegate call always implies an admin key on the\n caller because the delegatee contract can write arbitrarily to the state of\n the delegator, which severely limits the generality of contract composition."
        },
        "fullyImplemented": false,
        "linearizedBaseContracts": [
          37097
        ],
        "name": "IInterpreterV1",
        "nameLocation": "4360:14:196",
        "scope": 37098,
        "usedErrors": []
      }
    ],
    "license": "CAL"
  },
  "id": 196
}